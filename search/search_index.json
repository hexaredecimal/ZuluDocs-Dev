{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ZuluPL Zulu is a small, interpreted programming language that blends functional and imperative paradigms, offering a clean and expressive syntax. Key features Atoms & Simplicity \u2013 Atoms (:hello, :true) provide a lightweight way to represent immutable symbols without additional syntax overhead. Powerful List Constructs \u2013 Inspired by ML, [x, y] can be formed using x:y, enhancing readability and composability. Concise Function Definitions \u2013 Say goodbye to {} in function implementations. Functions are defined using = and . for clarity and brevity. Universal Block Expressions \u2013 Every block { ... } returns a value, making the language fully expression-oriented. Lambda Expressions \u2013 Inline functions use fn(args) => expr, making anonymous functions more intuitive. Struct types - Create data structures with methods and type functions Who is it for? Whether you're a hobbyist, a functional programming enthusiast, a systems programmer looking for a flexible scripting tool, or someone who enjoys experimenting with new languages, Zulu provides a refreshing approach to code structure and execution.","title":"Introduction"},{"location":"#welcome-to-zulupl","text":"Zulu is a small, interpreted programming language that blends functional and imperative paradigms, offering a clean and expressive syntax.","title":"Welcome to ZuluPL"},{"location":"#key-features","text":"Atoms & Simplicity \u2013 Atoms (:hello, :true) provide a lightweight way to represent immutable symbols without additional syntax overhead. Powerful List Constructs \u2013 Inspired by ML, [x, y] can be formed using x:y, enhancing readability and composability. Concise Function Definitions \u2013 Say goodbye to {} in function implementations. Functions are defined using = and . for clarity and brevity. Universal Block Expressions \u2013 Every block { ... } returns a value, making the language fully expression-oriented. Lambda Expressions \u2013 Inline functions use fn(args) => expr, making anonymous functions more intuitive. Struct types - Create data structures with methods and type functions","title":"Key features"},{"location":"#who-is-it-for","text":"Whether you're a hobbyist, a functional programming enthusiast, a systems programmer looking for a flexible scripting tool, or someone who enjoys experimenting with new languages, Zulu provides a refreshing approach to code structure and execution.","title":"Who is it for?"},{"location":"casting/","text":"Type Casting Despite being a dynamically typed language, Zulu allows us to cast between primitive constants. Casting is performed using the as keyword followed by the atom naming the target type. 300 as :string \"Hello\" as :atom \"420\" as :number Lists, tuples and maps cannot cast into other types and type casting is prohibited for user defined types.","title":"Type Casting"},{"location":"casting/#type-casting","text":"Despite being a dynamically typed language, Zulu allows us to cast between primitive constants. Casting is performed using the as keyword followed by the atom naming the target type. 300 as :string \"Hello\" as :atom \"420\" as :number Lists, tuples and maps cannot cast into other types and type casting is prohibited for user defined types.","title":"Type Casting"},{"location":"conditionals/","text":"Conditionals Conditional expressions allow use to make decisions and branch into different parts. Zulu supports the if expression. The if expression is divided into two parts: If without else if 1 > 2 then :greater This will return the atom :greater if 1 > 2, if not then the special atom :false is returned. If else if 2 == 2 then :equal else :not_equal This will return the atom :equal if 2 == 2, if not then the else expression will execute and return :not_equal .","title":"Conditionals"},{"location":"conditionals/#conditionals","text":"Conditional expressions allow use to make decisions and branch into different parts. Zulu supports the if expression. The if expression is divided into two parts:","title":"Conditionals"},{"location":"conditionals/#if-without-else","text":"if 1 > 2 then :greater This will return the atom :greater if 1 > 2, if not then the special atom :false is returned.","title":"If without else"},{"location":"conditionals/#if-else","text":"if 2 == 2 then :equal else :not_equal This will return the atom :equal if 2 == 2, if not then the else expression will execute and return :not_equal .","title":"If else"},{"location":"constants/","text":"Zulu language constants Atoms The most basic constant in Zulu is the atom constant. Atoms are named (or symbolic) constants, such that their name is their value. They are preceded with a leading : . Defining atoms Atoms are defined by a leading : and a series of letters, digits and underscores ( _ ). :hello :world :atom_too :year_2025 There are atoms that are special as they used to mark the absence of values and returned as the result of boolean expressions. These atoms are nil , true and false . :Nil The :nil atom is used as a value that stands in place of the absent value. :True and :False The :true and :false atoms are returned as the result of boolean expressions such as comparing two numbers, etc. All atoms even special atoms can be created by the programmer, even though some of them are also created by the interpreter at runtime. Numbers The second most basic constant in Zulu is the number. Numbers are used in mathematical expressions to compute values at runtime. Numbers can be both integer and decimal as they are not different at runtime. Numbers can contain _ as a visual separator. 200 50.5 600_500 Strings The third basic constant is the string constant. Strings are enclosed inside \" \" . String allow us to have values that represent text that can be modified and displayed. String are immutable in Zulu, operations such as concatination create a new string internally. \"Hello\" \"This is a string\" String can also be interpolated with other expressions from within their definition. \"${a} + ${b} = ${a + b}\" List The list constant allows use to store values of any type in a single storage unit. The list constant is declared in side the [] symbols. [3, 5, 6, 7, 8] [:one, :two, 3, \"four\", 5] Map The map constant is a reference constant that allows us to associate a key with a value. The map is declared like this: &{\"Hello\" -> \"World\", :one -> 4} The & symbol is the reference symbol, this is because maps are reference types by default. More on references in the coming chapters Tuple Tuples are used to store multiple items in a single variable. Tuples are similar to lists. They are declared using the () symbols. For a value to be a tuple it must have multiple values inside the () symbols, else it becomes are group expressions. (:hello, :nil) (\"Hello\", \"World\")","title":"Constants"},{"location":"constants/#zulu-language-constants","text":"","title":"Zulu language constants"},{"location":"constants/#atoms","text":"The most basic constant in Zulu is the atom constant. Atoms are named (or symbolic) constants, such that their name is their value. They are preceded with a leading : .","title":"Atoms"},{"location":"constants/#defining-atoms","text":"Atoms are defined by a leading : and a series of letters, digits and underscores ( _ ). :hello :world :atom_too :year_2025 There are atoms that are special as they used to mark the absence of values and returned as the result of boolean expressions. These atoms are nil , true and false .","title":"Defining atoms"},{"location":"constants/#nil","text":"The :nil atom is used as a value that stands in place of the absent value.","title":":Nil"},{"location":"constants/#true-and-false","text":"The :true and :false atoms are returned as the result of boolean expressions such as comparing two numbers, etc. All atoms even special atoms can be created by the programmer, even though some of them are also created by the interpreter at runtime.","title":":True and :False"},{"location":"constants/#numbers","text":"The second most basic constant in Zulu is the number. Numbers are used in mathematical expressions to compute values at runtime. Numbers can be both integer and decimal as they are not different at runtime. Numbers can contain _ as a visual separator. 200 50.5 600_500","title":"Numbers"},{"location":"constants/#strings","text":"The third basic constant is the string constant. Strings are enclosed inside \" \" . String allow us to have values that represent text that can be modified and displayed. String are immutable in Zulu, operations such as concatination create a new string internally. \"Hello\" \"This is a string\" String can also be interpolated with other expressions from within their definition. \"${a} + ${b} = ${a + b}\"","title":"Strings"},{"location":"constants/#list","text":"The list constant allows use to store values of any type in a single storage unit. The list constant is declared in side the [] symbols. [3, 5, 6, 7, 8] [:one, :two, 3, \"four\", 5]","title":"List"},{"location":"constants/#map","text":"The map constant is a reference constant that allows us to associate a key with a value. The map is declared like this: &{\"Hello\" -> \"World\", :one -> 4} The & symbol is the reference symbol, this is because maps are reference types by default. More on references in the coming chapters","title":"Map"},{"location":"constants/#tuple","text":"Tuples are used to store multiple items in a single variable. Tuples are similar to lists. They are declared using the () symbols. For a value to be a tuple it must have multiple values inside the () symbols, else it becomes are group expressions. (:hello, :nil) (\"Hello\", \"World\")","title":"Tuple"},{"location":"functions/","text":"Functions Zulu is said to be a functional programming language, that is to say, functions are first-class citizens in this language. Functions can be created, called, stored, passed to functions and returned from other functions. In this section I am just going to introduce the basic usage and creation of functions in Zulu. In Zulu all functions must always return a value. fn add(x, y) => x + y fn greet(name) => io::println(\"Hello \" + name) Clauses In Zulu functions can also use clauses as a way to match which function should be called. fn out(:stdout) => io::println(\"The clause has :stdout\") fn out(:stderr) => io::println(\"The clause has :stderr\") This allows us to simulate function overloading similar to languages such as java. In the code above the function out will have a different body depending on the input provided during the call. Clause guards Clauses can also have guards that only run the body when the guards match or result in true atoms. fn add(x, y) => where types::is_number(x) && types::is_number(y) => x / y The code above declares the add function with a clause that checks if the type of the input parameters is number. If true then the body will execute and if not an error will be raised. add(50, 6) // Fine add(\"Hello\", \"World\") // Error","title":"Functions"},{"location":"functions/#functions","text":"Zulu is said to be a functional programming language, that is to say, functions are first-class citizens in this language. Functions can be created, called, stored, passed to functions and returned from other functions. In this section I am just going to introduce the basic usage and creation of functions in Zulu. In Zulu all functions must always return a value. fn add(x, y) => x + y fn greet(name) => io::println(\"Hello \" + name)","title":"Functions"},{"location":"functions/#clauses","text":"In Zulu functions can also use clauses as a way to match which function should be called. fn out(:stdout) => io::println(\"The clause has :stdout\") fn out(:stderr) => io::println(\"The clause has :stderr\") This allows us to simulate function overloading similar to languages such as java. In the code above the function out will have a different body depending on the input provided during the call.","title":"Clauses"},{"location":"functions/#clause-guards","text":"Clauses can also have guards that only run the body when the guards match or result in true atoms. fn add(x, y) => where types::is_number(x) && types::is_number(y) => x / y The code above declares the add function with a clause that checks if the type of the input parameters is number. If true then the body will execute and if not an error will be raised. add(50, 6) // Fine add(\"Hello\", \"World\") // Error","title":"Clause guards"},{"location":"helloworld/","text":"HelloWorld Hello world is the most basic program a programmer can write. Lets get into the code and write our own version of the program in Zulu. module :main import :io fn main() => io::println(\"Hello, world\") Explanation The fist line module :main declares a module with the name main. All functions and type are declared inside modules in Zulu. Modules allow use to write reusable code, hence they are importable using the import keyword. The next line is the import statement ( import :io ), which imports the io module which contains functions for writing and reading to and from the standard output and input. You may have noticed that the module name and imported module are prefixed by a colon, that is because they are atoms. Atoms are discussed in the next chapter. We then get the first function definition for the main function. Functions are declared with the fn keyword followed by the name of the function. Main is a special function because it is used as the entry point for the program. Between the () input parameters can be listed. The function body is a single expression that is expected to follow the => symbol. All functions have a single expression as the body, in order to perform multiple expressions use the block expression. The block expression will also be discussed in the following chapters.","title":"First Program"},{"location":"helloworld/#helloworld","text":"Hello world is the most basic program a programmer can write. Lets get into the code and write our own version of the program in Zulu. module :main import :io fn main() => io::println(\"Hello, world\")","title":"HelloWorld"},{"location":"helloworld/#explanation","text":"The fist line module :main declares a module with the name main. All functions and type are declared inside modules in Zulu. Modules allow use to write reusable code, hence they are importable using the import keyword. The next line is the import statement ( import :io ), which imports the io module which contains functions for writing and reading to and from the standard output and input. You may have noticed that the module name and imported module are prefixed by a colon, that is because they are atoms. Atoms are discussed in the next chapter. We then get the first function definition for the main function. Functions are declared with the fn keyword followed by the name of the function. Main is a special function because it is used as the entry point for the program. Between the () input parameters can be listed. The function body is a single expression that is expected to follow the => symbol. All functions have a single expression as the body, in order to perform multiple expressions use the block expression. The block expression will also be discussed in the following chapters.","title":"Explanation"},{"location":"help/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About"},{"location":"help/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"help/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"help/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"match/","text":"Pattern Matching The match expression allows you to check if a value is an expected value or type. The match expression takes a match expression, followed by a list of match cases and their respective bodies to run if they match. The default case is represented by an underscore symbol. Lets match some values. Constant Matching When matching constants the match expression behaves like a switch statement. It checks if the match expression is equals to the case. match :true | :false -> io::println(\"False\") | :true -> io::println(\"True\") Tuple Matching match (\"Hello\", :nil) | (t, :nil) -> io::println(\"The tuple has \" + t + \" and :nil\") | (_, _) -> io::println(\"The tuple has unexpected values\") | _ -> io::println(\"Some non tuple expression was passed\") The code above matches the tuple (\"Hello\", :nil) with the match cases below. If a case matches then its body runs. The case that will match here is the first one (t, :nil) . In this case t will be a match variable that has the value \"Hello\" since it matches the first value of the tuple and the second value is matched directly using the atom. List Matching List pattern matching works similarly to languages such as Ocaml and Standard ML. match [1,2,3,4] | [head:tail] -> io::println(\"Head = \" + head + \", tail = \" + tail) | [one] -> io::println(\"The list has only one value: \" + one) | [] -> io::println(\"The list is empty\") The code above matches the list [1,2,3,4] . In this match expression the first case will match because it tries to grab the top value in the list and assign it to head, then assign a new list of the other values to tail. This will succeed because the list has enough items to create the new list after the top item has been created.","title":"Pattern Matching"},{"location":"match/#pattern-matching","text":"The match expression allows you to check if a value is an expected value or type. The match expression takes a match expression, followed by a list of match cases and their respective bodies to run if they match. The default case is represented by an underscore symbol. Lets match some values.","title":"Pattern Matching"},{"location":"match/#constant-matching","text":"When matching constants the match expression behaves like a switch statement. It checks if the match expression is equals to the case. match :true | :false -> io::println(\"False\") | :true -> io::println(\"True\")","title":"Constant Matching"},{"location":"match/#tuple-matching","text":"match (\"Hello\", :nil) | (t, :nil) -> io::println(\"The tuple has \" + t + \" and :nil\") | (_, _) -> io::println(\"The tuple has unexpected values\") | _ -> io::println(\"Some non tuple expression was passed\") The code above matches the tuple (\"Hello\", :nil) with the match cases below. If a case matches then its body runs. The case that will match here is the first one (t, :nil) . In this case t will be a match variable that has the value \"Hello\" since it matches the first value of the tuple and the second value is matched directly using the atom.","title":"Tuple Matching"},{"location":"match/#list-matching","text":"List pattern matching works similarly to languages such as Ocaml and Standard ML. match [1,2,3,4] | [head:tail] -> io::println(\"Head = \" + head + \", tail = \" + tail) | [one] -> io::println(\"The list has only one value: \" + one) | [] -> io::println(\"The list is empty\") The code above matches the list [1,2,3,4] . In this match expression the first case will match because it tries to grab the top value in the list and assign it to head, then assign a new list of the other values to tail. This will succeed because the list has enough items to create the new list after the top item has been created.","title":"List Matching"},{"location":"operators/","text":"Operators Operators play a crucial role in computing values in programs and calculations in general. Zulu supports binary, logical bitwise, list and unary operators. All operators are listed below. Binary Operators Operator Description + Adds two numbers, also concats strings - Subtracts two numbers * Multiplies two numbers / Divides two numbers mod Computes the modulus of two numbers Logical Operators Operator Description > Checks if the left side it greater than the right side < Checks if the left side it less than the right side >= Checks if the left side it greater or equal than the right side <= Checks if the left side it less or equal than the right side == Checks if the left side it equal than the right side != Checks if the left side it not equal than the right side && Performs a logical and || Performs a logical or Bitwise Operators Operator Description << Performs a left shift between two numbers >> Performs a right shift between two numbers and Performs a bitwise and between two numbers or Performs a bitwise or between two numbers List Operators Operator Description <| Constructs a new list from two values Unary Operators Operator Description ! Performs a bitwise not - Negates a number or expression","title":"Operators"},{"location":"operators/#operators","text":"Operators play a crucial role in computing values in programs and calculations in general. Zulu supports binary, logical bitwise, list and unary operators. All operators are listed below.","title":"Operators"},{"location":"operators/#binary-operators","text":"Operator Description + Adds two numbers, also concats strings - Subtracts two numbers * Multiplies two numbers / Divides two numbers mod Computes the modulus of two numbers","title":"Binary Operators"},{"location":"operators/#logical-operators","text":"Operator Description > Checks if the left side it greater than the right side < Checks if the left side it less than the right side >= Checks if the left side it greater or equal than the right side <= Checks if the left side it less or equal than the right side == Checks if the left side it equal than the right side != Checks if the left side it not equal than the right side && Performs a logical and || Performs a logical or","title":"Logical Operators"},{"location":"operators/#bitwise-operators","text":"Operator Description << Performs a left shift between two numbers >> Performs a right shift between two numbers and Performs a bitwise and between two numbers or Performs a bitwise or between two numbers","title":"Bitwise Operators"},{"location":"operators/#list-operators","text":"Operator Description <| Constructs a new list from two values","title":"List Operators"},{"location":"operators/#unary-operators","text":"Operator Description ! Performs a bitwise not - Negates a number or expression","title":"Unary Operators"},{"location":"structs/","text":"User defined data structures User defined data structures are a very import feature in any modern programming language that wants to be taken seriously. They allow us to describe and model complex data structures using the built-in types and other user defined structures. type Person struct {name, age} The code above declares a new user defined type Person that has two fields, name and age . To create an instance of this type use the following syntax. Person {name: \"John\", age: 45} User defined data structures can also have methods, both type methods and instance methods. impl Person = fn new(name, age) where types::is_string(name) && types::is_number(age) => Person {name: name, age: age} fn greet(self) => io::println(\"Hello, my name is ${self.name}\") ; Inside the impl block, functions that have self as the first argument are instance methods and the rest are simply type methods.","title":"Structs"},{"location":"structs/#user-defined-data-structures","text":"User defined data structures are a very import feature in any modern programming language that wants to be taken seriously. They allow us to describe and model complex data structures using the built-in types and other user defined structures. type Person struct {name, age} The code above declares a new user defined type Person that has two fields, name and age . To create an instance of this type use the following syntax. Person {name: \"John\", age: 45} User defined data structures can also have methods, both type methods and instance methods. impl Person = fn new(name, age) where types::is_string(name) && types::is_number(age) => Person {name: name, age: age} fn greet(self) => io::println(\"Hello, my name is ${self.name}\") ; Inside the impl block, functions that have self as the first argument are instance methods and the rest are simply type methods.","title":"User defined data structures"},{"location":"variables/","text":"Variables A variable is a named storage location that holds a value or data. These values can change during the execution of a program. Variables are essential for storing and manipulating data in computer programs. In Zulu variables are declared using the let keyword followed by the in keyword, used to mark start the expression that they might be used for. let name = \"John Doe\" result = math::PI() * 2 in io::println(\"Hello \" + name + \" 2 x PI is \" + result) The code above declares two variables, name and result . Both variables are used in the string concatination expression and the result is printed to the standard output. You can think of the space between let and in as the variable declaration zone and then after the in is the expression zone.","title":"Variables"},{"location":"variables/#variables","text":"A variable is a named storage location that holds a value or data. These values can change during the execution of a program. Variables are essential for storing and manipulating data in computer programs. In Zulu variables are declared using the let keyword followed by the in keyword, used to mark start the expression that they might be used for. let name = \"John Doe\" result = math::PI() * 2 in io::println(\"Hello \" + name + \" 2 x PI is \" + result) The code above declares two variables, name and result . Both variables are used in the string concatination expression and the result is printed to the standard output. You can think of the space between let and in as the variable declaration zone and then after the in is the expression zone.","title":"Variables"}]}